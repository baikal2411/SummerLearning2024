# 暑期学习2024/6/23	清华大学电子工程系软件培训笔记

## LEARNING GIT

preknowledge

![image-20240623115637503](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623115637503.png)

## BOOK 1 pro git

[Git 基础 · Pro Git 第二版 简体中文 (gitbooks.io)](https://bingohuang.gitbooks.io/progit2/content/01-introduction/sections/basics.html)

[首页 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/)

- Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。
- Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。

![image-20240623142310963](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623142310963.png)

### 【配置】

因为 Git 会从不同的文件中读取同一个配置（例如：`/etc/gitconfig` 与 `~/.gitconfig`）。 这种情况下，Git 会用它找到的每一个变量的最后一个配置。

```markdown
$ git config --list
```

可以通过输入 `git config <key>`： 来检查 Git 的某一项配置

### 【获取帮助手册】

使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：

```console
$ git help <verb>
$ git <verb> --help
$ man git-<verb>
e.g. $ git help config
```

### 【获取 Git 仓库】

Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 `git clone` 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库（虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在

比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：

```console
$ git clone https://github.com/libgit2/libgit2
```

这会在当前目录下创建一个名为 ``libgit2'' 的目录，`并在这个目录下初始化一个 `.git` 文件夹，从远程仓库拉取下所有数据放入 `.git` 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 `libgit2` 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：

```console
$ git clone https://github.com/libgit2/libgit2 mylibgit
```

这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 `mylibgit`。

Git 支持多种数据传输协议。 上面的例子使用的是 `https://` 协议，不过你也可以使用 `git://` 协议或者使用 SSH 传输协议，比如 `user@server:path/to/repo.git` 。

要查看哪些文件处于什么状态，可以用 `git status` 命令

使用命令 `git add` 开始跟踪一个文件，`git add` 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。

### 【暂存已修改文件】

```markdown
$ git add
```

这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“**添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适**。

实际上 Git 只不过暂存了你运行 `git add` 命令时的版本， 如果你现在提交，`CONTRIBUTING.md` 的版本是你最后一次运行 `git add` 命令时的那个版本，而不是你运行 `git commit` 时，在工作目录中的当前版本。 所以，运行了 `git add` 之后又作了修订的文件，**需要重新运行** `git add` 把最新版本重新暂存起来

### 【状态简览】

使用 `git status -s` 命令或 `git status --short` 命令，你将得到一种更为紧凑的格式输出。

新添加的未跟踪文件前面有 `??` 标记，新添加到暂存区中的文件前面有 `A` 标记，修改过的文件前面有 `M` 标记。 你可能注意到了 `M` 有两个可以出现的位置，出现在右边的 `M` 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 `M` 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： `README` 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,`lib/simplegit.rb` 文件被修改了并将修改后的文件放入了暂存区。 而 `Rakefile` 在工作区被**修改并提交到暂存区后又在工作区中被修改了**（所以还需要再add一次），所以在暂存区和工作区都有该文件被修改了的记录。

### 【忽略文件gitignore】

一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 `.gitignore` 的文件，列出要忽略的文件模式。 来看一个实际的例子：

```console
$ cat .gitignore
*.[oa]
*~
```

第一行告诉 Git 忽略所有以 `.o` 或 `.a` 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。

文件 `.gitignore` 的格式规范如下：

- 所有空行或者以 `＃` 开头的行都会被 Git 忽略。
- 可以使用标准的 glob 模式匹配。
- 匹配模式可以以（`/`）开头防止递归。
- 匹配模式可以以（`/`）结尾指定目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（`!`）取反。

![image-20240623150911289](C:\Users\30241\AppData\Roaming\Typora\typora-user-images\image-20240623150911289.png)

```markdown
# no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory
doc/**/*.pdf
```

GitHub 有一个十分详细的针对数十种项目及语言的 `.gitignore` 文件列表，你可以在 https://github.com/github/gitignore 找到它.

### 【查看已暂存和未暂存的修改】

尽管 `git status` 已经通过在相应栏下列出文件名的方式回答了这个问题，`git diff` 将通过文件补丁的格式显示具体哪些行发生了改变。

要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 `git diff`：

此命令比较的是**<u>工作目录中当前文件和暂存区域快照之间的差异</u>**， 也就是修改之后还没有暂存起来的变化内容。

若要查看已暂存的<u>**将要添加到下次提交里**</u>的内容，可以用 `git diff --cached` 命令。（Git 1.6.1 及更高版本还允许使用 `git diff --staged`，效果是相同的，但更好记些。

<u>**git diff 本身只显示尚未暂存的改动**！！！！！</u>

### 【提交更新】

每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了， 然后再运行提交命令 `git commit`

这种方式会启动文本编辑器以便输入本次提交的说明。

也可以在 `commit` 命令后添加 `-m` 选项，将提交信息与命令放在同一行

### 【跳过add指令的办法】

Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤：

```console
$ git commit -a -m 'added new benchmarks'
```

### 【版本回退】

Git必须知道当前版本是哪个版本，在Git中，用`HEAD`表示当前版本，也就是最新的提交`1094adb...`（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。

```markdown
使用$ git reset --hard HEAD^进行回退
```

或者找到commit id进行回退：

```markdown
$ git reset --hard 1094a
```

<img src="C:\Users\30241\AppData\Roaming\Typora\typora-user-images\image-20240623153456179.png" alt="image-20240623153456179" style="zoom:50%;" />

<img src="C:\Users\30241\AppData\Roaming\Typora\typora-user-images\image-20240623153640393.png" alt="image-20240623153640393" style="zoom:50%;" />

如上图，版本回退只是改变指针的指向

Git提供了一个命令`git reflog`用来记录你的每一次命令id,使用此方法进行查询

### 【撤销修改】

`git checkout`其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

`git checkout -- file`可以丢弃<u>**工作区**</u>的修改

命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到`git checkout`命令。

一种是自修改后<u>还没有被放到暂存区</u>，现在，撤销修改就回到和版本库一模一样的状态；

一种是已经添加到<u>**暂存区**</u>后，又<u>作了修改</u>，现在，撤销修改就回到添加到暂存区后的状态。

`git reset`命令既可以回退版本，也可以把**暂存区**的修改<u>回退到工作区</u>。当我们用`HEAD`时，表示最新的版本。注意，这里与版本回退不同，没有`--`

```markdown
$ git reset HEAD readme.txt
```

回退到工作区以后再使用checkout来丢弃修改

![image-20240623154616489](C:\Users\30241\AppData\Roaming\Typora\typora-user-images\image-20240623154616489.png)

### 【移除文件】

要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 `git rm` 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。

确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`：

```
$ git rm test.txt
rm 'test.txt'

$ git commit -m "remove test.txt"
```

删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：

```
$ git checkout -- test.txt
```











## BOOK 2   GitHub入门与实践 made by 大塚弘记

```markdown

```

