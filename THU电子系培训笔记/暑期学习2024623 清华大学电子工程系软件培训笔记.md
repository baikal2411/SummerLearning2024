# 暑期学习2024/6/23	清华大学电子工程系软件培训笔记

好好学[单片机](https://www.zhihu.com/search?q=单片机&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2925321805})/Arm，因为做Zynq的时候要用，毕竟不是所有场景都会用Linux，SDK起个程序能满足交互功能就足够了

好好学计算机（计算机组成原理，[计算机体系结构](https://www.zhihu.com/search?q=计算机体系结构&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2925321805})，操作系统）

好好学总线（I2C, SPI, AXI…）

好好学[接口](https://www.zhihu.com/search?q=接口&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2925321805})（ETH，HDMI，PCI/E，UART，USB）

好好学DDR（DDR3，DDR4，SDRAM）

好好学[脚本](https://www.zhihu.com/search?q=脚本&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2925321805})（Python，makefile，TCL）

好好学system verilog （学完[verilog](https://www.zhihu.com/search?q=verilog&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2925321805})再学，尤其是验证相关的，广义验证）

好好学Linux （会用就行，但启动和[设备树](https://www.zhihu.com/search?q=设备树&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2925321805})很重要）

好好学原语 (不需要精通，但是知道它的作用和用法，说不定有意想不到的效果)

好好学[时钟域](https://www.zhihu.com/search?q=时钟域&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2925321805})(CDC，时序分析，[时序优化](https://www.zhihu.com/search?q=时序优化&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2925321805})，STA)

好好学优化方法(主要指PPA，还有一些边界优化方法)

好好学EDA软件( Quartus, Questa, Vivado, Vitis, modelsim, VCS )

只有我要好好学DSA，神经网络，Overlay，CGRA（多看paper）(不做这个方向的可以不看)

作者：路边的小溪
链接：https://www.zhihu.com/question/587930144/answer/2925321805
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## LEARNING GIT

preknowledge

![image-20240623115637503](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623115637503.png)

VISUALIZING GIT WITH D3

[使用 D3 解释 Git (onlywei.github.io)](https://onlywei.github.io/explain-git-with-d3/#commit)

## BOOK 1 pro git

[Git 基础 · Pro Git 第二版 简体中文 (gitbooks.io)](https://bingohuang.gitbooks.io/progit2/content/01-introduction/sections/basics.html)

[首页 - 廖雪峰的官方网站 (liaoxuefeng.com)](https://www.liaoxuefeng.com/)

- Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。
- Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。

![image-20240623142310963](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623142310963.png)

### 【配置】

因为 Git 会从不同的文件中读取同一个配置（例如：`/etc/gitconfig` 与 `~/.gitconfig`）。 这种情况下，Git 会用它找到的每一个变量的最后一个配置。

```markdown
$ git config --list
```

可以通过输入 `git config <key>`： 来检查 Git 的某一项配置

### 【获取帮助手册】

使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：

```console
$ git help <verb>
$ git <verb> --help
$ man git-<verb>
e.g. $ git help config
```

### 【获取 Git 仓库】

Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。 当你执行 `git clone` 命令的时候，默认配置下远程 Git 仓库中的每一个文件的每一个版本都将被拉取下来。 事实上，如果你的服务器的磁盘坏掉了，你通常可以使用任何一个克隆下来的用户端来重建服务器上的仓库（虽然可能会丢失某些服务器端的挂钩设置，但是所有版本的数据仍在

比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：

```console
$ git clone https://github.com/libgit2/libgit2
```

这会在当前目录下创建一个名为 ``libgit2'' 的目录，`并在这个目录下初始化一个 `.git` 文件夹，从远程仓库拉取下所有数据放入 `.git` 文件夹，然后从中读取最新版本的文件的拷贝。 如果你进入到这个新建的 `libgit2` 文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。 如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：

```console
$ git clone https://github.com/libgit2/libgit2 mylibgit
```

这将执行与上一个命令相同的操作，不过在本地创建的仓库名字变为 `mylibgit`。

Git 支持多种数据传输协议。 上面的例子使用的是 `https://` 协议，不过你也可以使用 `git://` 协议或者使用 SSH 传输协议，比如 `user@server:path/to/repo.git` 。

要查看哪些文件处于什么状态，可以用 `git status` 命令

使用命令 `git add` 开始跟踪一个文件，`git add` 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。

### 【暂存已修改文件】

```markdown
$ git add
```

这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。 将这个命令理解为“**添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适**。

实际上 Git 只不过暂存了你运行 `git add` 命令时的版本， 如果你现在提交，`CONTRIBUTING.md` 的版本是你最后一次运行 `git add` 命令时的那个版本，而不是你运行 `git commit` 时，在工作目录中的当前版本。 所以，运行了 `git add` 之后又作了修订的文件，**需要重新运行** `git add` 把最新版本重新暂存起来

### 【状态简览】

使用 `git status -s` 命令或 `git status --short` 命令，你将得到一种更为紧凑的格式输出。

新添加的未跟踪文件前面有 `??` 标记，新添加到暂存区中的文件前面有 `A` 标记，修改过的文件前面有 `M` 标记。 你可能注意到了 `M` 有两个可以出现的位置，出现在右边的 `M` 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 `M` 表示该文件被修改了并放入了暂存区。 例如，上面的状态报告显示： `README` 文件在工作区被修改了但是还没有将修改后的文件放入暂存区,`lib/simplegit.rb` 文件被修改了并将修改后的文件放入了暂存区。 而 `Rakefile` 在工作区被**修改并提交到暂存区后又在工作区中被修改了**（所以还需要再add一次），所以在暂存区和工作区都有该文件被修改了的记录。

### 【忽略文件gitignore】

一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表。 通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。 在这种情况下，我们可以创建一个名为 `.gitignore` 的文件，列出要忽略的文件模式。 来看一个实际的例子：

```console
$ cat .gitignore
*.[oa]
*~
```

第一行告诉 Git 忽略所有以 `.o` 或 `.a` 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。 第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。 此外，你可能还需要忽略 log，tmp 或者 pid 目录，以及自动生成的文档等等。 要养成一开始就设置好 .gitignore 文件的习惯，以免将来误提交这类无用的文件。

文件 `.gitignore` 的格式规范如下：

- 所有空行或者以 `＃` 开头的行都会被 Git 忽略。
- 可以使用标准的 glob 模式匹配。
- 匹配模式可以以（`/`）开头防止递归。
- 匹配模式可以以（`/`）结尾指定目录。
- 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（`!`）取反。

![image-20240623150911289](C:\Users\30241\AppData\Roaming\Typora\typora-user-images\image-20240623150911289.png)

```markdown
# no .a files
*.a

# but do track lib.a, even though you're ignoring .a files above
!lib.a

# only ignore the TODO file in the current directory, not subdir/TODO
/TODO

# ignore all files in the build/ directory
build/

# ignore doc/notes.txt, but not doc/server/arch.txt
doc/*.txt

# ignore all .pdf files in the doc/ directory
doc/**/*.pdf
```

GitHub 有一个十分详细的针对数十种项目及语言的 `.gitignore` 文件列表，你可以在 https://github.com/github/gitignore 找到它.

### 【查看已暂存和未暂存的修改】

尽管 `git status` 已经通过在相应栏下列出文件名的方式回答了这个问题，`git diff` 将通过文件补丁的格式显示具体哪些行发生了改变。

要查看尚未暂存的文件更新了哪些部分，不加参数直接输入 `git diff`：

此命令比较的是**<u>工作目录中当前文件和暂存区域快照之间的差异</u>**， 也就是修改之后还没有暂存起来的变化内容。

若要查看已暂存的<u>**将要添加到下次提交里**</u>的内容，可以用 `git diff --cached` 命令。（Git 1.6.1 及更高版本还允许使用 `git diff --staged`，效果是相同的，但更好记些。

<u>**git diff 本身只显示尚未暂存的改动**！！！！！</u>

### 【提交更新】

每次准备提交前，先用 `git status` 看下，是不是都已暂存起来了， 然后再运行提交命令 `git commit`

这种方式会启动文本编辑器以便输入本次提交的说明。

也可以在 `commit` 命令后添加 `-m` 选项，将提交信息与命令放在同一行

### 【跳过add指令的办法】

Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 `git commit` 加上 `-a` 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 `git add` 步骤：

```console
$ git commit -a -m 'added new benchmarks'
```

### 【版本回退】

Git必须知道当前版本是哪个版本，在Git中，用`HEAD`表示当前版本，也就是最新的提交`1094adb...`（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。

```markdown
使用$ git reset --hard HEAD^进行回退
```

或者找到commit id进行回退：

```markdown
$ git reset --hard 1094a
```

<img src="C:\Users\30241\AppData\Roaming\Typora\typora-user-images\image-20240623153456179.png" alt="image-20240623153456179" style="zoom:50%;" />

<img src="C:\Users\30241\AppData\Roaming\Typora\typora-user-images\image-20240623153640393.png" alt="image-20240623153640393" style="zoom:50%;" />

如上图，版本回退只是改变指针的指向

Git提供了一个命令`git reflog`用来记录你的每一次命令id,使用此方法进行查询

### 【撤销修改】

`git checkout--`其实是用版本库里的版本替换**工作区的版本**，无论工作区是修改还是删除，都可以“一键还原”。

`git checkout -- file`可以丢弃<u>**工作区**</u>的修改

命令中的`--`很重要，没有`--`，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到`git checkout`命令。

一种是自修改后<u>还没有被放到暂存区</u>，现在，撤销修改就回到和版本库一模一样的状态；

一种是已经添加到<u>**暂存区**</u>后，又<u>作了修改</u>，现在，撤销修改就回到添加到暂存区后的状态。

`git reset`命令既可以回退版本，也可以把**暂存区**的修改<u>回退到工作区</u>。当我们用`HEAD`时，表示最新的版本。注意，这里与版本回退不同，没有`--`

<u>就是取消暂存文件！！！</u>

```markdown
$ git reset HEAD readme.txt
```

回退到工作区以后再使用checkout来丢弃修改

![image-20240623154616489](C:\Users\30241\AppData\Roaming\Typora\typora-user-images\image-20240623154616489.png)

### 【移除文件】

要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。 可以用 `git rm` 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。

git rm就是删文件，并且<u>把删文件的修改提交到暂存区</u>

相当于rm删文件后，git add 提交，保存修改

确实要从版本库中删除该文件，那就用命令`git rm`删掉，并且`git commit`：

```
$ git rm test.txt
rm 'test.txt'

$ git commit -m "remove test.txt"
```

删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：

```
$ git checkout -- test.txt
```

不删除工作区的文件，只是移除出版本库，使用：

```
git rm -r --cached  <file>
```

## GitHub与远程仓库

### 【本地库关联远程库】

**1.git remote add origin https://github.com/自己的github账户名/learn-git.git**

**2.git branch -M master**

**3.git push -u origin master**

你的本地库名字叫learngit，远程库全名叫https://github.com/自己的github账户名/learn-git.git

但每次推送让你敲个全名你会疯的，所以起个别名origin

每次敲命令git push origin master的时候，git看到origin，就去当前库的配置文件里找，看看它的全名到底写的啥

你也可以起别的名字，如果有多个远程库，那必然不同的远程库对应不同的名字

如果添加的时候地址写错了，或者就是想删除远程库，可以用`git remote rm <name>`命令。使用前，建议先用`git remote -v`查看远程库信息：

```
$ git remote -v
origin  git@github.com:michaelliao/learn-git.git (fetch)
origin  git@github.com:michaelliao/learn-git.git (push)
```

然后，根据名字删除，比如删除`origin`：

```
$ git remote rm origin
```

### 【从远程库克隆】

```
$ git clone git https://github.com/baikal2411/SummerLearning2024.git
```

### 【分支】

![image-20240623164545794](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623164545794.png)

![image-20240623164622365](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623164622365.png)

![image-20240623170957738](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623170957738.png)

![image-20240623171014105](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623171014105.png)

![image-20240623171032094](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623171032094.png)

创建分支： 

```
git branch dev
```

切换分支：

```
git checkout dev
```

等同于这样一个命令：表示创建并且切换

```
git checkout -b dev
```

查看分支：当前分支上会有一个`*`号

```
git branch
```

合并分支：

```
git merge dev
```

删除分支：

```
git branch -d dev
```

当同时修改master和分支时可能会有冲突，此时不能快速合并：

![image-20240623172416779](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623172416779.png)

解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。

用`git log --graph`命令可以看到分支合并图

如果要强制禁用`Fast forward`模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。

下面我们实战一下`--no-ff`方式：

```
$ git merge --no-ff -m "merge with no-ff" dev
```

![image-20240623172732567](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623172732567.png)

![image-20240623172752066](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623172752066.png)

### 【BUG分支】

`stash`功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：

首先确定要在哪个分支上修复bug，假定需要在`master`分支上修复，就从`master`创建临时分支：

```markdown
$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 6 commits.
  (use "git push" to publish your local commits)

$ git checkout -b issue-101
Switched to a new branch 'issue-101'
```

现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交：

```
$ git add readme.txt 
$ git commit -m "fix bug 101"
```

修复完成后，切换到`master`分支，并完成合并，最后删除`issue-101`分支：

```markdown
$ git switch master
$ git merge --no-ff -m "merged bug fix 101" issue-101
```

```markdown
$ git switch dev
```

此时dev分支内没有工作现场！

刚才的工作现场存到哪去了？用`git stash list`命令看看：

```
$ git stash list
stash@{0}: WIP on dev: f52c633 add merge
```

工作现场还在，Git把stash内容存在某个地方了，但需要恢复一下，有两个办法：

一是用`git stash apply`恢复，但是恢复后，stash内容并不删除，你需要用`git stash drop`来删除；

另一种方式是用`git stash pop`，恢复的同时把stash内容也删了：

```
$ git stash pop
On branch dev
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

	new file:   hello.py

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   readme.txt

Dropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a)
```

再用`git stash list`查看，就看不到任何stash内容了：

```
$ git stash list
```

你可以多次stash，恢复的时候，先用`git stash list`查看，然后恢复指定的stash，用命令：

```
$ git stash apply stash@{0}
```

同样的bug，要在dev上修复，我们只需要把`4c805e2 fix bug 101`这个提交所做的修改“复制”到dev分支。注意：我们只想复制`4c805e2 fix bug 101`这个提交所做的修改，并不是把整个master分支merge过来。

为了方便操作，Git专门提供了一个`cherry-pick`命令，让我们能复制一个特定的提交到当前分支：

```
$ git cherry-pick 4c805e2
```

在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要`git stash`命令保存现场，才能从dev分支切换到master分支。

当手头工作没有完成时，先把工作现场`git stash`一下，然后去修复bug，修复后，再`git stash pop`，回到工作现场；

【在master分支上修复的bug，想要合并到当前dev分支，可以用`git cherry-pick <commit>`命令，把bug提交的修改“复制”到当前分支，避免重复劳动。】

自己尝试了一下，发现 git stash 只能缓存被跟踪的文件，本次新增的文件并不能被缓存，需要先 add 进暂存区之后才能被缓存。

开发一个新feature，最好新建一个分支；

如果要丢弃一个没有被合并过的分支，可通过`git branch -D <name>`强行删除。

### 【多人协作】

![image-20240623180104807](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623180104807.png)

![image-20240623180426021](D:\desktop\暑假计划\THU电子系培训笔记\image-20240623180426021.png)

创建远程库的分支到本地作为分支：

```
$ git checkout -b dev origin/dev
```

再根据需求推送到远程：这里是处于`dev`分支上的

```
$ git add env.txt
$ git commit -m "add env"
$ git push origin dev
```

- 查看远程库信息，使用`git remote -v`；
- 本地新建的分支如果不推送到远程，对其他人就是不可见的；
- 从本地推送分支，使用`git push origin branch-name`，如果推送失败，先用`git pull`抓取远程的新提交；
- 在本地创建和远程分支对应的分支，使用`git checkout -b branch-name origin/branch-name`，本地和远程分支的名称最好一致；
- 建立本地分支和远程分支的关联，使用`git branch --set-upstream branch-name origin/branch-name`；
- 从远程抓取分支，使用`git pull`，如果有冲突，要先处理冲突。

### **TAG的处理**

首先切换到分支上

```markdown
$ git switch dev
```

然后再打标签：

```markdown
$ git tag v1.0
```

通过日志查询找到commit的ID，然后再打标签：

```
$ git tag v1.0 426ec32
```

可以创建带有说明的标签，用`-a`指定标签名，`-m`指定说明文字：

```
$ git tag -a v0.1 -m "version 0.1 released" 1094adb
```

命令`git show <tagname>`可以看到说明文字

删除操作：

```markdown
$ git tag -d v0.1
```

推送到远程，使用

```
git push origin<tagname>
```

标签已经推送到远程，则先从本地删除：

```
$ git tag -d v0.9
```

然后从远程删除：

```
$ git push origin :refs/tags/v0.9
```

## BOOK 2   GitHub入门与实践 made by 大塚弘记

